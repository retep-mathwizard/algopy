#!/usr/bin/env python3
#[0,1,2,3,4,5,6,7,8]
class GameState:
    def __init__(self,board):
        self.board = board
        self.winning_combos = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,8]]
    def is_gameover(self):
        if self.board.count('X') + self.board.count('O') == 9:
            return True
        for combo in self.winning_combos:
            print(combo)
            if (self.board[combo[0]] == 'X' and self.board[combo[1]] == 'X' and self.board[combo[2]] == 'X') or (self.board[combo[0]] == 'O' and self.board[combo[1]] == 'O' and self.board[combo[2]] == 'O'):
                return True
        return False
    def get_possible_moves(self):
        squares = []
        for square in self.board:
            if square != 'X' and square != 'O':
                squares.append(int(square))
        return squares
    def get_next_state(self, move, computer_turn):
        copy = list(self.board)
        if computer_turn:
            copy[move] = 'X'
        else:
            copy[move] = 'O'
        return GameState(copy)

def evals(game_state):
    the_combos = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]]
    for combo in the_combos:
        if game_state.board[combo[0]] == 'X' and game_state.board[combo[1]] == 'X' and game_state.board[combo[2]] == 'X':
            print('WIN',game_state.board)
            return 1    
        elif game_state.board[combo[1]] == 'O' and game_state.board[combo[0]] == 'O' and game_state.board[combo[2]] == 'O':
            print('LOSS',game_state.board)
            return -1
    else:
        return 0

#http://giocc.com/concise-implementation-of-minimax-through-higher-order-functions.html
def max_play(game_state):
    if game_state.is_gameover():
        return evals(game_state)
    return max(map(lambda move: min_play(game_state.get_next_state(move, True)), game_state.get_possible_moves()))
def min_play(game_state):
    #http://stackoverflow.com/questions/890128/why-are-python-lambdas-useful
    if game_state.is_gameover():
        return evals(game_state)
    return min(map(lambda move: max_play(game_state.get_next_state(move, False)), game_state.get_possible_moves()))

def minimax(game_state):
    moves = game_state.get_possible_moves()
    print('possible moves are:'+str(moves))
    best_move = None
    best_score = -2
    for move in moves:
        clone = game_state.get_next_state(move, True)
        score = min_play(clone)
        if score > best_score:
            best_move = move
            best_score = score
    return [{'best move':best_move}, {'best score':best_score}]

'''
tests:
XOX
OX 
X _ _
'''
game = GameState(['X','X','O','O',4,5,'X',7,8])
game1 = GameState(['X','O','X','O','X',5,'X',7,8])
game2 = GameState(['X','X','O','O','O',5,'X',7,8])
game3 = GameState(['X','X','O','O','X',5,'X','X',8])
game4 = GameState(['X','X','O','O','X',5,'X',7,'X'])
evals(game)
evals(game1)
evals(game2)
evals(game3)
evals(game4)
